进程：process（进程是一组资源，他构成了一个正在运行的程序，这些资源包括虚拟地址空间，文件句柄以及程序启动需要其他东西的载体。【启动一个程序则系统开启一个进程】）
线程：thread（在进程种开辟一个内核对象，线程体现了进程所执行的具体操作，一旦程序准备完毕，系统则从线程中main反法的第一条执行【则开辟了一个线程，默认情况下一个进程只包含一个线程】）
异步编程（多线程）：[同步编程：从程序的第一行语句执行到最后一行，中途不做任何其他操作，则称之为同步]，[异步编程：程序发起多个线程，在相同的时间内一起执行（存在不同一时间）]



一个进程中有多个线程，同时完成进程的任务，进程中又有共享资源，可以让线程进行分享，但有些共享资源使用有限制，一次只能够一个线程使用，
这时就需要加一把锁对这个贡献资源设置限制，"互斥锁"（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。
还有些共享资源有固定的使用线程数量，需要进行排队共享，"信号量"（Semaphore），用来保证多个线程不会互相冲突。
mutex是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。
（1）以多进程形式，允许多个任务同时运行；
（2）以多线程形式，允许单个任务分成不同的部分运行；
（3）提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。


Lock
this 表示的就是当前实例，当你再new一个的时候，锁定的就不再是同一个对象了。 
不能锁定值类型的原因是，当这个值类型传递到另一个线程的时候，会创建一个副本，锁定的也不再是同一个对象了。
锁定字符串带来的问题是，字符串在CLR中会暂存在 内存中，如果有两个变量被分配了相同的字符串内容，
那么这两个引用会指向同一块内存，实际锁定也就是同一个对象，这就会导致整个应用程序的阻塞。所以锁定字符串是非常危险的行为。



使用线程：
无参无返回值线程使用：Thread th = new Thread(new ThreadStart(无参无返回值方法名))
该语句只是创建一个线程，并写入main函数启动的主进程中，并不会直接调用线程中的操作，需要使用th.start()调用线程开始

带参无返回值：Thread th = new Thread(new ParameterizedThreadStart(方法名))
带参的线程调用需要在：th.start(参数)，带参的线程方法参数类型需要定义成objecrt类型，这样就可接受所有的参数类型

ThreadState：检测进程状态，unstarted（暂停），sleeping（休眠），running（运行中）

前台进程与后台进程：默认创建的进程都为前台进程，在进程运行后将无法改变进程类型，需要在创建时指定进程类型，Thread.IsBackground指
定是否为后台进程，当一个线程中有指定后台线程，则前台线程执行完后程序结束（如果后台线程并没执行完照样结束），所以
后台线程并不执行重要功能。

通过begin×××方法运行的线程都是后台线程异步回调委托

在c#中不允许跨线程操作，使用（分布式计算）则可以进行跨进程访问
Control.CheckForIllegalCrossThreadCalls = false; 屏蔽c#对跨线程调用检测，此做法可能导致线程不安全，在winForm中如果将线程设置为后台线程则无法操作主线程也就是
control线程中的资源。
 control.invoke(参数delegate)方法:在拥有此控件的基础窗口句柄的线程上执行指定的委托。使用主线程执行委托回调


func<>，Action<>这两个都是用来接收一个方法，委托类型
func<>：，1一返回值，16个入参，17个重载，不管怎么样都需要一个返回值泛型定义的最后一个类型则为返回值类型
Action<>：支持16个入参

一个进程中存在一个主线程，每当该进程调用一个方法时则算是启动了一个线程，但是在主线程中启动的方法归类为主线程资源，使用同步、异步、委托或使用thread
则归类为子线程